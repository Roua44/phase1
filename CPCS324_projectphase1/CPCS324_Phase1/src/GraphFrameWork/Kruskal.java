package GraphFrameWork;

import java.util.Arrays;
import java.util.Comparator;

public class Kruskal extends MSTAlgorthim {

    private Edge[] result; // Array to store the result MST
    double startTime = 0;
    double finishTime = 0;

    public Kruskal(Graph g) {
        super(g);
        this.result = new Edge[V]; // initialize the result array with V elements
    }

    // Find set of an element i
    private int find(int[] parent, int i) {
        if (parent[i] == -1) {
            return i;
        }
        return find(parent, parent[i]);
    }

    // Union of two sets represented by x and y
    private void union(int[] parent, int x, int y) {
        int xset = find(parent, x);
        int yset = find(parent, y);
        parent[xset] = yset;
    }

    @Override
    public void DisplyResultingMST(int choice) {
        startTime = System.nanoTime();

        int e = 0; // An index variable, used for result[]
        int i = 0; // An index variable, used for sorted edges

        // Step 1: Sort all the edges in non-decreasing order of their weight
        Edge[] edges = new Edge[V * (V - 1) / 2]; // initialize edge array with max number of edges
        for (int k = 0; k < edges.length; k++) {
            edges[k] = new Edge(0, 0, 0);
        }
        int index = 0;
        for (int j = 0; j < V; j++) { // iterate through all vertices to get all edges
            for (Vertex v : adj.get(j)) {
                if (v.dest > j) { // avoid adding duplicate edges
                    edges[index++] = new Edge(j, v.dest, v.weight); // add edge to edge array
                }
            }
        }
        Arrays.sort(edges, Comparator.comparingInt(e1 -> e1.weight)); // sort edges by weight

        int[] parent = new int[V];
        Arrays.fill(parent, -1); // initialize parent array

        // Step 2: Pick the smallest edge and check if it forms a cycle
        while (e < V - 1 && i < (V * (V - 1) / 2)) { // iterate till we get V-1 edges or run out of edges
            Edge next_edge = edges[i];
            int x = find(parent, next_edge.src);
            int y = find(parent, next_edge.dest);
            if (x != y) { // if adding the edge doesn't form a cycle
                result[e] = next_edge; // add edge to MST
                e++;
                union(parent, x, y); // union the sets
            }
            i++;
        }

        // Step 3: Print the MST
        if (choice == 2) { // if user chose to display MST
            int minCost = 0, x = 0;
            System.out.println("The phone network (minimum spanning tree) generated by Kruskal's algorithm \n"
                    + "is as follows: ");
            for (i = 0; i < e; i++) {
                Edge currentEdge = result[i];
                if (currentEdge != null) {
                    System.out.println("Office No." + ((char) (currentEdge.src + 'A' + x)) + " - " + "Office No." + ((char) (currentEdge.dest + 'A'))
                            + " : " + currentEdge.displyInfo()); // display the edge
                    minCost += currentEdge.weight;
                    x++;
                }
            }
            System.out.println("The cost of designed phone network: " + minCost); // display the total cost of MST
        }

        finishTime = System.nanoTime(); // calculate finish time
        double totalTime = (finishTime - startTime) / 10000; // calculate total time
        if (choice == 1) { // if user chose to display runtime
            System.out.println("Runtime (in Milliseconds) : " + totalTime + "\n");
        }
    }
}